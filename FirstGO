package main

import (
	"bytes"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

type LoginResponse struct {
	Request_Id     string
	Lease_Id       string
	Renewable      bool
	Lease_Duration int
	Data           string
	Wrap_Info      string
	Warnings       string
	Auth           Auth
}

type CertLoginInput struct {
	Vaulturl  string
	Role      string
	Namespace string
	CertPath  string
	KeyPath   string
}

type Metadata struct {
	Authority_Key_Id string
	Cert_Name        string
	Common_Name      string
	Serial_Number    string
	Subject_Key_Id   string
}

type Auth struct {
	Client_Token    string
	Accessor        string
	Policies        []string
	Token_Policies  []string
	Metadata        Metadata
	Lease_Duration  int
	Renewable       bool
	Entity_Id       string
	Token_Type      string
	Orphan          bool
	Mfa_Requirement string
	Num_Uses        int
}

type ReadMetadata struct {
	Created_Time    time.Time `json:"created_time"`
	Custom_Metadata string
	Deletion_Time   time.Time
	Destroyed       bool
	Version         int
}

type ReadData struct {
	Data map[string]string `json:"data"`
}

type ReadResponse struct {
	Request_Id     string
	Lease_Id       string
	Renewable      bool
	Lease_Duration int
	Data           ReadData
	Wrap_Info      string
	Warnings       string
	Auth           Auth
	Metadata       ReadMetadata `json:"data"`
}

func main() {
	err := GetRotationDate()
	if err != nil {
		log.Fatalf("Error getting rotation date: %v", err)
	}
}

func GetRotationDate() error {
	loginInput := CertLoginInput{
		Vaulturl:  "https://vault.eu.eva.ubs.net/v1",
		Role:      "cert_fa29643",
		Namespace: "AT3657",
		CertPath:  "uat.runtime.crt",
		KeyPath:   "uat.runtime.key",
	}

	accessToken, err := CertLogin(loginInput)
	if err != nil {
		return fmt.Errorf("error logging in: %v", err)
	}

	url := "https://vault.eu.eva.ubs.net/v1/secret/data/runtime/a96ad003a6e00cb3ff1f49bce347f4baf6c96f2b29c51b66136e523871ae19b0/svc_efiduat"

	// Create the request
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return fmt.Errorf("failed to create request: %v", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-Vault-Token", accessToken)
	req.Header.Set("X-Vault-Namespace", loginInput.Namespace)

	// Create TLS client
	client, err := createTLSClient(loginInput.CertPath, loginInput.KeyPath)
	if err != nil {
		return fmt.Errorf("failed to create TLS client: %v", err)
	}

	// Execute the request
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("request failed: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("request returned status: %v", resp.Status)
	}

	// Read the response body
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response body: %v", err)
	}

	var readResponse ReadResponse
	err = json.Unmarshal(body, &readResponse)
	if err != nil {
		return fmt.Errorf("failed to unmarshal response: %v", err)
	}

	createdTime := readResponse.Metadata.Created_Time

	// Calculate the difference between current time and created time
	now := time.Now()
	duration := now.Sub(createdTime)

	// Check if the duration is less than 11 months
	if duration < (11 * 30 * 24 * time.Hour) { // Rough approximation of 11 months
		fmt.Printf("Time passed since created: %v\n", duration)
	} else {
		fmt.Println("Time passed is greater than 11 months")
	}

	return nil
}

func CertLogin(input CertLoginInput) (string, error) {
	values := map[string]string{"name": input.Role}
	jsonStr, err := json.Marshal(values)
	if err != nil {
		return "", fmt.Errorf("failed to marshal login values: %v", err)
	}

	req, err := http.NewRequest("POST", input.Vaulturl+"/auth/cert/login", bytes.NewBuffer(jsonStr))
	if err != nil {
		return "", fmt.Errorf("failed to create login request: %v", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-Vault-Namespace", input.Namespace)

	client, err := createTLSClient(input.CertPath, input.KeyPath)
	if err != nil {
		return "", fmt.Errorf("failed to create TLS client: %v", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("login request failed: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("login request returned status: %v", resp.Status)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read login response body: %v", err)
	}

	var loginResponse LoginResponse
	err = json.Unmarshal(body, &loginResponse)
	if err != nil {
		return "", fmt.Errorf("failed to unmarshal login response: %v", err)
	}

	return loginResponse.Auth.Client_Token, nil
}

func createTLSClient(certPath, keyPath string) (*http.Client, error) {
	x509cert, err := tls.LoadX509KeyPair(certPath, keyPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load X509 key pair: %v", err)
	}

	tr := &http.Transport{
		TLSClientConfig: &tls.Config{Certificates: []tls.Certificate{x509cert}},
	}

	return &http.Client{Transport: tr}, nil
}
