package main

import (
	"bytes"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

type LoginResponse struct {
	RequestId     string `json:"request_id"`
	LeaseId       string `json:"lease_id"`
	Renewable     bool   `json:"renewable"`
	LeaseDuration int    `json:"lease_duration"`
	Data          string `json:"data"`
	WrapInfo      string `json:"wrap_info"`
	Warnings      string `json:"warnings"`
	Auth          Auth   `json:"auth"`
}

type CertLoginInput struct {
	Vaulturl  string
	Role      string
	Namespace string
	CertPath  string
	KeyPath   string
}

type Metadata struct {
	AuthorityKeyId string `json:"authority_key_id"`
	CertName       string `json:"cert_name"`
	CommonName     string `json:"common_name"`
	SerialNumber   string `json:"serial_number"`
	SubjectKeyId   string `json:"subject_key_id"`
}

type Auth struct {
	ClientToken    string   `json:"client_token"`
	Accessor       string   `json:"accessor"`
	Policies       []string `json:"policies"`
	TokenPolicies  []string `json:"token_policies"`
	Metadata       Metadata `json:"metadata"`
	LeaseDuration  int      `json:"lease_duration"`
	Renewable      bool     `json:"renewable"`
	EntityId       string   `json:"entity_id"`
	TokenType      string   `json:"token_type"`
	Orphan         bool     `json:"orphan"`
	MfaRequirement string   `json:"mfa_requirement"`
	NumUses        int      `json:"num_uses"`
}

type ReadMetadata struct {
	CreatedTime    string `json:"created_time"`
	CustomMetadata string `json:"custom_metadata"`
	DeletionTime   string `json:"deletion_time"`
	Destroyed      bool   `json:"destroyed"`
	Version        int    `json:"version"`
}

type ReadData struct {
	Data     map[string]string `json:"data"`
	Metadata ReadMetadata      `json:"metadata"`
}

type ReadResponse struct {
	RequestId     string   `json:"request_id"`
	LeaseId       string   `json:"lease_id"`
	Renewable      bool   `json:"renewable"`
	LeaseDuration int      `json:"lease_duration"`
	Data          ReadData `json:"data"`
	WrapInfo      string   `json:"wrap_info"`
	Warnings      string   `json:"warnings"`
	Auth          Auth     `json:"auth"`
}

func main() {
	err := GetRotationDate()
	if err != nil {
		log.Fatalf("Error getting rotation date: %v", err)
	}
}

func GetRotationDate() error {
	loginInput := CertLoginInput{
		Vaulturl:  "https://vault.eu.eva.ubs.net/v1",
		Role:      "cert_fa29643",
		Namespace: "AT3657",
		CertPath:  "uat.runtime.crt",
		KeyPath:   "uat.runtime.key",
	}

	accessToken, err := CertLogin(loginInput)
	if err != nil {
		return fmt.Errorf("error logging in: %v", err)
	}

	url := "https://vault.eu.eva.ubs.net/v1/secret/data/runtime/a96ad003a6e00cb3ff1f49bce347f4baf6c96f2b29c51b66136e523871ae19b0/svc_efiduat"

	// Create the request
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return fmt.Errorf("failed to create request: %v", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-Vault-Token", accessToken)
	req.Header.Set("X-Vault-Namespace", loginInput.Namespace)

	// Create TLS client
	client, err := createTLSClient(loginInput.CertPath, loginInput.KeyPath)
	if err != nil {
		return fmt.Errorf("failed to create TLS client: %v", err)
	}

	// Execute the request
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("request failed: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("request returned status: %v", resp.Status)
	}

	// Read the response body
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response body: %v", err)
	}

	var readResponse ReadResponse
	err = json.Unmarshal(body, &readResponse)
	if err != nil {
		return fmt.Errorf("failed to unmarshal response: %v", err)
	}

	createdTime, err := time.Parse(time.RFC3339, readResponse.Data.Metadata.CreatedTime)
	if err != nil {
		return fmt.Errorf("failed to parse created_time: %v", err)
	}

	// Calculate the difference between current time and created time
	now := time.Now()
	duration := now.Sub(createdTime)

	// Check if the duration is less than 11 months
	if duration < (11 * 30 * 24 * time.Hour) { // Rough approximation of 11 months
		fmt.Printf("Time passed since created: %v\n", duration)
	} else {
		fmt.Println("Time passed is greater than 11 months")
	}

	return nil
}

func CertLogin(input CertLoginInput) (string, error) {
	values := map[string]string{"name": input.Role}
	jsonStr, err := json.Marshal(values)
	if err != nil {
		return "", fmt.Errorf("failed to marshal login values: %v", err)
	}

	req, err := http.NewRequest("POST", input.Vaulturl+"/auth/cert/login", bytes.NewBuffer(jsonStr))
	if err != nil {
		return "", fmt.Errorf("failed to create login request: %v", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-Vault-Namespace", input.Namespace)

	client, err := createTLSClient(input.CertPath, input.KeyPath)
	if err != nil {
		return "", fmt.Errorf("failed to create TLS client: %v", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("login request failed: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("login request returned status: %v", resp.Status)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read login response body: %v", err)
	}

	var loginResponse LoginResponse
	err = json.Unmarshal(body, &loginResponse)
	if err != nil {
		return "", fmt.Errorf("failed to unmarshal login response: %v", err)
	}

	return loginResponse.Auth.ClientToken, nil
}

func createTLSClient(certPath, keyPath string) (*http.Client, error) {
	x509cert, err := tls.LoadX509KeyPair(certPath, keyPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load X509 key pair: %v", err)
	}

	tr := &http.Transport{
		TLSClientConfig: &tls.Config{Certificates: []tls.Certificate{x509cert}},
	}

	return &http.Client{Transport: tr}, nil
}
