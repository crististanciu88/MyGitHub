package yourpackage

import (
    "encoding/json"
    "io/ioutil"
    "os"
    "path/filepath"
    "testing"
)

// Create a temporary config file for testing
func createTempConfigFile(content string) (string, error) {
    tmpFile, err := ioutil.TempFile("", "test_config_*.json")
    if err != nil {
        return "", err
    }
    if _, err := tmpFile.Write([]byte(content)); err != nil {
        return "", err
    }
    tmpFile.Close()
    return tmpFile.Name(), nil
}

// Compare the contents of two Config structs for equality
func CompareConfigs(a, b Config) bool {
    if len(a.SecretsToRotate) != len(b.SecretsToRotate) {
        return false
    }
    for i := range a.SecretsToRotate {
        if a.SecretsToRotate[i] != b.SecretsToRotate[i] {
            return false
        }
    }

    return a.Namespace == b.Namespace &&
        a.EvaVaultURL == b.EvaVaultURL &&
        a.SvcAccount == b.SvcAccount &&
        a.RuntimeCert == b.RuntimeCert &&
        a.RuntimeKey == b.RuntimeKey &&
        a.RuntimeSvcAccount == b.RuntimeSvcAccount &&
        a.DeploySvcAccount == b.DeploySvcAccount &&
        a.DeployCert == b.DeployCert &&
        a.DeployKey == b.DeployKey &&
        a.EvaApiURL == b.EvaApiURL &&
        a.AzTenantID == b.AzTenantID &&
        len(a.EvaUsers) == len(b.EvaUsers) && 
        func() bool { 
            for i := range a.EvaUsers {
                if a.EvaUsers[i] != b.EvaUsers[i] {
                    return false
                }
            }
            return true
        }()
}

func TestLoadConfig(t *testing.T) {
    originalEnv := os.Getenv("ENV")
    defer os.Setenv("ENV", originalEnv) // Restore original ENV

    tests := []struct {
        env            string
        configContent  string
        expectError    bool
        expectedConfig *Config
    }{
        {
            env: "test",
            configContent: `{
                "SecretsToRotate": ["secret1", "secret2"],
                "Namespace": "testNamespace",
                "EvaVaultURL": "http://example.com/vault",
                "EvaUsers": [{"User": "alice", "VaultPath": "/path/to/alice", "Domain": "domain.com"}],
                "SvcAccount": "testAccount",
                "RuntimeCert": "testCert",
                "RuntimeKey": "testKey",
                "RuntimeSvcAccount": "testRuntimeSvcAccount",
                "DeploySvcAccount": "testDeploySvcAccount",
                "DeployCert": "testDeployCert",
                "DeployKey": "testDeployKey",
                "EvaApiURL": "http://example.com/api",
                "AzTenantID": "azure-tenant-id"
            }`,
            expectError: false,
            expectedConfig: &Config{
                SecretsToRotate:  []string{"secret1", "secret2"},
                Namespace:        "testNamespace",
                EvaVaultURL:     "http://example.com/vault",
                EvaUsers:        []EvaUser{{User: "alice", VaultPath: "/path/to/alice", Domain: "domain.com"}},
                SvcAccount:      "testAccount",
                RuntimeCert:     "testCert",
                RuntimeKey:      "testKey",
                RuntimeSvcAccount: "testRuntimeSvcAccount",
                DeploySvcAccount: "testDeploySvcAccount",
                DeployCert:      "testDeployCert",
                DeployKey:       "testDeployKey",
                EvaApiURL:      "http://example.com/api",
                AzTenantID:      "azure-tenant-id",
            },
        },
        {
            env:         "missing", // Test case for a missing config file
            expectError: true,
        },
        {
            env: "invalid", // Test case for invalid JSON
            configContent: `{"invalid_json": true`,
            expectError:  true,
        },
    }

    // Get the current executable path
    executablePath, err := os.Executable()
    if err != nil {
        t.Fatalf("Failed to get executable path: %v", err)
    }

    for _, test := range tests {
        t.Run(test.env, func(t *testing.T) {
            var configFilePath string
            if test.env != "missing" {
                var err error
                configFilePath, err = createTempConfigFile(test.configContent)
                if err != nil {
                    t.Fatalf("Failed to create temp config file: %v", err)
                }
                defer os.Remove(configFilePath) // Clean up the temp file

                // Set the environment variable for the test
                os.Setenv("ENV", test.env)
            }

            // Call LoadConfig with the mocked executable path
            // Use the actual executable path constructed with the environment variable (the path for temporary file)
            if test.env != "missing" {
                os.Setenv("ENV", filepath.Base(configFilePath))
            } else {
                // For the "missing" case, we can point to the regular executable path
                os.Setenv("ENV", "missing")
            }

            // Call LoadConfig
            config, err := LoadConfig(executablePath)

            if test.expectError {
                if err == nil {
                    t.Errorf("Expected error but got none")
                }
                return // Stop further checks if an error was expected
            }

            if err != nil {
                t.Fatalf("Did not expect to fail: %v", err)
            }

            // Use CompareConfigs function to compare results
            if !CompareConfigs(*config, *test.expectedConfig) {
                t.Errorf("Expected config %+v, but got %+v", *test.expectedConfig, *config)
            }
        })
    }
}
